// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDandName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDandNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	LookupApplicationBoxesByID(ctx echo.Context, applicationId uint64, params LookupApplicationBoxesByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDandName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDandName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDandNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDandName(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxesByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxesByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxesByIDParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxesByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDandName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.LookupApplicationBoxesByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/OJGjn5xpOzj+4//PwAA//9tFFUj11sBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
