// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Cr+4kaNfHCn7+P7j/wsAAP//WinCZKRbAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
