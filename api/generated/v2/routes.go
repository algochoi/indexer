// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDandName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDandNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDandName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDandName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDandNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDandName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDandName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
